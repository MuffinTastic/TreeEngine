#include "interfaces/imanagedhostsystem.h"

#include <functional>
#include <filesystem>

#include <scope_guard/scope_guard.hpp>

#include <corehost/nethost.h>
#include <corehost/hostfxr.h>
#include <corehost/coreclr_delegates.h>

#include "interfaces/ilogsystem.h"
#include "Tree.NativeCommon/sys.h"

#include "sap/common.h"
#include "sap/string.h"

#define TREE_TRUNK_ASSEMBLY_NAME "Tree.Trunk"

// Managed shared libraries end in .dll no matter the platform
#define MANAGED_ASSEMBLY_EXT ".dll"
#define MANAGED_RUNTIMECFG_EXT ".runtimeconfig.json"

#ifdef _WCHAR_T_DEFINED

#endif

namespace Tree
{
	class ManagedHostSystem : public IManagedHostSystem
	{
	public:
		virtual ESystemInitCode Startup() override;
		virtual void Shutdown() override;

	private:
		std::shared_ptr<ILogger> m_logger;

		Platform::SharedLibrary* m_hostfxrLibrary = nullptr;

		// I would use std::function here, but these typedefs are incompatible with it
		hostfxr_initialize_for_runtime_config_fn m_initRuntimeFn;
		//hostfxr_set_error_writer_fn m_setRuntimeErrorWriterFn;
		hostfxr_get_runtime_delegate_fn m_getRuntimeDelegateFn;
		hostfxr_set_runtime_property_value_fn m_setRuntimePropertyFn;
		hostfxr_close_fn m_closeFn;

		load_assembly_fn m_loadAssemblyFn;
		get_function_pointer_fn m_getFunctionPointerFn;

		bool LoadHostFXR();
		void UnloadHostFXR();

		bool LoadNETCore();

		bool LoadTreeTrunk();
	};
}


REGISTER_TREE_SYSTEM( ManagedHostSystem, MANAGEDHOSTSYSTEM_NAME )


Tree::ESystemInitCode Tree::ManagedHostSystem::Startup()
{
	m_logger = Sys::Log()->CreateLogger( "ManagedHost" );

	if ( !LoadHostFXR() )
	{
		return ESYSTEMINIT_FAILURE;
	}

	if ( !LoadNETCore() )
	{
		UnloadHostFXR();
		return ESYSTEMINIT_FAILURE;
	}

	m_logger->Info( "Loaded .NET Core" );

	if ( !LoadTreeTrunk() )
	{
		UnloadHostFXR();
		return ESYSTEMINIT_FAILURE;
	}

	m_logger->Info( "Loaded Tree.Trunk" );

    return ESYSTEMINIT_SUCCESS;
}

void Tree::ManagedHostSystem::Shutdown()
{

	UnloadHostFXR();
}

bool Tree::ManagedHostSystem::LoadHostFXR()
{
	// I sure hope this is cross-platform

	char_t u16path[512];
	size_t bufferSize = sizeof( u16path ) / sizeof( char_t );

	if ( get_hostfxr_path( u16path, &bufferSize, nullptr ) != 0 )
	{
		m_logger->Error( "Couldn't find HostFXR" );
		return false;
	}

	std::filesystem::path hostfxrPath( u16path );
	m_hostfxrLibrary = Platform::LoadSharedLibrary( hostfxrPath );
	if ( !m_hostfxrLibrary )
	{
		m_logger->Error( "Couldn't load HostFXR at '{}'", Platform::PathToUTF8( hostfxrPath ) );
		return false;
	}

	m_initRuntimeFn = static_cast<hostfxr_initialize_for_runtime_config_fn>(
		Platform::GetSharedLibraryFunc(m_hostfxrLibrary, "hostfxr_initialize_for_runtime_config" ) );
	//m_setRuntimeErrorWriterFn = static_cast<hostfxr_set_error_writer_fn>(
	//	Platform::GetSharedLibraryFunc( m_hostfxrLibrary, "hostfxr_set_error_writer" ) );
	m_getRuntimeDelegateFn = static_cast<hostfxr_get_runtime_delegate_fn>(
		Platform::GetSharedLibraryFunc( m_hostfxrLibrary, "hostfxr_get_runtime_delegate" ) );
	m_setRuntimePropertyFn = static_cast<hostfxr_set_runtime_property_value_fn>(
		Platform::GetSharedLibraryFunc( m_hostfxrLibrary, "hostfxr_set_runtime_property_value" ) );
	m_closeFn = static_cast<hostfxr_close_fn>(
		Platform::GetSharedLibraryFunc( m_hostfxrLibrary, "hostfxr_close" ) );

	if ( !m_initRuntimeFn
		//|| !m_setRuntimeErrorWriterFn
		|| !m_getRuntimeDelegateFn
		|| !m_setRuntimePropertyFn
		|| !m_closeFn )
	{
		m_logger->Error( "Couldn't load all HostFXR functions" );
		Platform::UnloadSharedLibrary( m_hostfxrLibrary );
		return false;
	}

	return true;
}

void Tree::ManagedHostSystem::UnloadHostFXR()
{
	if ( m_hostfxrLibrary )
	{
		Platform::UnloadSharedLibrary( m_hostfxrLibrary );
		m_hostfxrLibrary = nullptr;
	}
}

bool Tree::ManagedHostSystem::LoadNETCore()
{
	std::filesystem::path enginePath = Platform::GetEngineDirectoryPath();
	std::wstring wEnginePath = enginePath.wstring();

	// Though this is for the entire runtime, we just piggyback off of Tree.Trunk's autogenerated config
	std::filesystem::path configPath = ( enginePath / TREE_TRUNK_ASSEMBLY_NAME MANAGED_RUNTIMECFG_EXT );
	std::wstring wConfigPath = configPath.wstring();

	hostfxr_handle context = nullptr;
	int rc = m_initRuntimeFn( wConfigPath.c_str(), nullptr, &context );
	if ( rc != 0 || context == nullptr )
	{
		m_logger->Error( "Failed to init runtime with config '{}', error code {}", Platform::PathToUTF8( configPath ), rc );
		return false;
	}

	auto contextGuard = sg::make_scope_guard( [=]
		{
			m_closeFn( context );
		} );

	m_setRuntimePropertyFn( context, SAP_STR("APP_CONTEXT_BASE_DIRECTORY"), wEnginePath.c_str() );
	m_setRuntimePropertyFn( context, SAP_STR("APP_PATHS"), wEnginePath.c_str() );
	m_setRuntimePropertyFn( context, SAP_STR("APP_NI_PATHS"), wEnginePath.c_str() );
	m_setRuntimePropertyFn( context, SAP_STR("NATIVE_DLL_SEARCH_DIRECTORIES"), wEnginePath.c_str() );
	m_setRuntimePropertyFn( context, SAP_STR("PLATFORM_RESOURCE_ROOTS"), wEnginePath.c_str() );

	void* loadAssemblyFn = nullptr;
	void* getFunctionPointerFn = nullptr;

	rc = m_getRuntimeDelegateFn( context, hdt_load_assembly, &loadAssemblyFn );
	if ( rc != 0 || loadAssemblyFn == nullptr )
	{
		m_logger->Error( "Couldn't get .NET Runtime load_assembly delegate" );
		return false;
	}

	rc = m_getRuntimeDelegateFn( context, hdt_get_function_pointer, &getFunctionPointerFn );
	if ( rc != 0 || getFunctionPointerFn == nullptr )
	{
		m_logger->Error( "Couldn't get .NET Runtime get_function_pointer delegate" );
		return false;
	}

	m_loadAssemblyFn = static_cast<load_assembly_fn>( loadAssemblyFn );
	m_getFunctionPointerFn = static_cast<get_function_pointer_fn>( getFunctionPointerFn );

	return true;
}

void TestPRintYeaaggh( Tree::Sap::SapString str )
{
	std::string contensts = str;
	Tree::Sys::Log()->Info( "This is the thing: {}", contensts );
}

bool Tree::ManagedHostSystem::LoadTreeTrunk()
{
	std::filesystem::path enginePath = Platform::GetEngineDirectoryPath();
	std::filesystem::path assemblyPath = ( enginePath / TREE_TRUNK_ASSEMBLY_NAME MANAGED_ASSEMBLY_EXT );
	std::wstring wAssemblyPath = assemblyPath.wstring();

	m_loadAssemblyFn( wAssemblyPath.c_str(), nullptr, nullptr );

	void* testFn = nullptr;

	m_getFunctionPointerFn(
		SAP_STR("Tree.Trunk.SapEntry, Tree.Trunk"),
		SAP_STR("Entry"),
		UNMANAGEDCALLERSONLY_METHOD,
		nullptr, nullptr,
		&testFn
	);

	if ( testFn == nullptr )
	{
		m_logger->Error( "Couldn't get Tree.Trunk entrypoint" );
		return false;
	}

	static_cast<void ( * )( void* )>( testFn )( &TestPRintYeaaggh );

	return true;
}
